#include<stdio.h>
#include<iostream>
#include<vector>
using namespace std; 

// 1차 복습 풀이시간 : 20분 (복습 필요 / 다양한 풀이법 복습하기)
// 2차 복습 풀이시간 : 13분 (복습 필요 / 예외처리 누락)

/*

<38. Inversion Sequence(삽입정렬 응용)> 

1부터 n까지의 수를 한 번씩만 사용하여 이루어진 수열이 있을 때, 
1부터 n까지 각각의 수 앞에 놓여 있는 자신보다 큰 수들의 
개수를 수열로 표현한 것을 Inversion Sequence라 한다.

예를 들어 다음과 같은 수열의 경우
4 8 6 2 5 1 3 7

1앞에 놓인 1보다 큰 수는 4, 8, 6, 2, 5. 이렇게 5개이고,
2앞에 놓인 2보다 큰 수는 4, 8, 6. 이렇게 3개,
3앞에 놓인 3보다 큰 수는 4, 8, 6, 5 이렇게 4개......
따라서 4 8 6 2 5 1 3 7의 inversion sequence는 5 3 4 0 2 1 1 0 이 된다.

n과 1부터 n까지의 수를 사용하여 이루어진 수열의 inversion sequence가 주어졌을 때, 
원래의 수열을 출력하는 프로그램을 작성하세요.

=============================================================================

▶ 입력설명
첫 번째 줄에 자연수 N(3 <= N < 100)이 주어지고, 
두 번째 줄에는 inversion sequence가 숫자 사이에 한 칸의 공백을 두고 주어진다.

▶ 출력설명
원래의 수열을 출력한다. 

=============================================================================

▶ 입력예제
8
5 3 4 0 2 1 1 0

▶ 출력예제
4 8 6 2 5 1 3 7

*/

int main()
{
	// 최초의 풀이 (강의 풀이보다 성능이 우수)

	/*
	// 첫 번째 줄에 자연수 N(3 <= N < 100)이 주어지고,
	// 두 번째 줄에는 inversion sequence가 숫자 사이에 한 칸의 공백을 두고 주어진다.

	int n, input, temp;
	int res[100]{ 0 };

	cin >> n;

	// 배열을 2개 사용하지 않고 입력과 동시에 정렬 가능 

	for (int i = 0; i < n; i++)
	{
		cin >> input;

		temp = 0;

		for (int j = 0; j < n; j++)
		{
			// temp 횟수는 채웠지만 0이 아닌 수는 자신보다 작은 수이므로 해당 경우는 건너뛰어야 함. 
			// 값을 입력한 뒤에는 반드시 break 해주어야 함. 아니면 뒤에 숫자까지 다 채워버림. 

			if (temp >= input && res[j] == 0)
			{
				res[j] = i + 1;
				break;
			}

			if (res[j] == 0 || res[j] > i + 1) temp++;
		}
	}

	// 원래의 수열을 출력한다. 

	for (int i = 0; i < n; i++)
	{
		cout << res[i] << " ";
	}
	*/

	//============================================================================//

	// 강의 풀이 (삽입정렬 사용. 가독성이 떨어지고 메모리 사용량이 더 많다.)	

	/*
	int n, pos;

	cin >> n;

	vector<int> is(n + 1), os(n + 1);

	for (int i = 1; i <= n; i++)
	{
		cin >> is[i];
	}

	for (int i = n; i > 0; i--)
	{
		pos = i;

		for (int j = 1; j <= is[i]; j++)
		{
			os[pos] = os[pos + 1];
			pos++;
		}

		os[pos] = i;
	}

	for (int i = 1; i <= n; i++)
	{
		cout << os[i] << " ";
	}
	*/

	//============================================================================//

	// 강의 풀이 정리 

	int n, pos; 

	cin >> n; 

	vector<int> is(n, 0), os(n, 0);

	for (int i = 0; i < n; i++)
	{
		cin >> is[i];
	}

	// 마지막 인덱스부터 시작
	// 자신보다 큰 수가 존재하는 횟수만큼 뒤에 있는 수(더 큰 수)를 
	// 앞으로 땡기고 그 뒤에 해당 수를 삽입 

	for (int i = n - 1; i >= 0; i--)
	{
		pos = i; 

		for (int j = 0; j < is[i]; j++)
		{
			os[pos] = os[pos + 1];
			pos++;
		}

		os[pos] = i + 1;
	}

	for (int i = 0; i < n; i++)
	{
		cout << os[i] << " ";
	}

	return 0;
}