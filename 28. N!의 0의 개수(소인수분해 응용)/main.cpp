#include<stdio.h>
#include<iostream>
#include<vector>
using namespace std; 

// 1차 복습 풀이시간 : 7분 

/*

<28. N!의 0의 개수(소인수분해 응용)>

자연수 N이 입력되면 N! 값에서 
일의 자리부터 연속적으로 ‘0’이 몇 개 있는지 구하는 프로그램을 작성하세요.

만약 5! = 5 × 4 × 3 × 2 × 1 = 120으로 일의자리부터 연속적된 ‘0’의 개수는 1입니다.
만약 12! = 479001600으로 일의자리부터 연속적된 ‘0’의 개수는 2입니다.

=============================================================================

▶ 입력설명
첫 줄에 자연수 N(10 <= N <= 1,000)이 입력된다.

▶ 출력설명
일의 자리부터 연속된 0의 개수를 출력합니다.

=============================================================================

▶ 입력예제
12

▶ 출력예제
2

*/

int main()
{
	// 최초의 풀이 
	
	// 직접 팩토리얼 값을 구하여 1의 자리부터 0의 개수를 구하려고 시도하였으나 실패. 
	// 팩토리얼 값은 13 이상만 되어도 int 데이터형이 수용할 수 없을 정도로 커진다. (long long도 마찬가지)
	// 따라서 소인수분해하여 문제에 접근하는 방식으로 해야 한다. 

	/*
	// 만약 5! = 5 × 4 × 3 × 2 × 1 = 120으로 일의자리부터 연속적된 ‘0’의 개수는 1입니다.
	// 만약 12!= 479001600으로 일의자리부터 연속적된 ‘0’의 개수는 2입니다.

	int n, j, temp, count = 0;

	cin >> n; 
	
	vector<int> factor(n + 1, 0);

	for (int i = 2; i <= n; i++)
	{
		temp = i;
		j = 2;

		while (1)
		{
			if (temp % j == 0)
			{
				temp /= j;
				factor[j]++;
			}
			else j++;

			if (temp == 1) break;
		}
	}

	count = factor[2];

	if (factor[5] < factor[2]) count = factor[5];

	// 일의 자리부터 연속된 0의 개수를 출력합니다.
	printf("%d\n", count);
	*/

	//============================================================================//

	// 강의 풀이 (꼭 필요한 변수만 사용하여 공간복잡도가 더 우수)

	int n, j, temp, cnt1 = 0, cnt2 = 0;

	cin >> n;

	for (int i = 2; i <= n; i++)
	{
		// i의 값은 index로 사용해야 하므로 직접 변경 불가 
		temp = i; 
		j = 2;

		while (1)
		{
			if (temp % j == 0)
			{
				temp /= j;
				if (j == 2) cnt1++;
				else if (j == 5) cnt2++;
			}
			else j++;

			if (temp == 1) break;
		}
	}

	(cnt1 >= cnt2) ? printf("%d\n", cnt2) : printf("%d\n", cnt1);

	return 0;
}