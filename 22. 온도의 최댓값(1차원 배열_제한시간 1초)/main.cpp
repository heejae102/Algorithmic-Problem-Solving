#include<stdio.h>
#include<iostream>
#include<limits>
#include<vector>
using namespace std;
 
// 1차 복습 풀이시간 : 8분 
// 2차 복습 풀이시간 : 7분 이내 

/*

<22. 온도의 최댓값(1차원 배열 : 제한시간 1초)>

매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 
연속적인 며칠동안의 온도의 합이 가장 큰 값을 알아보고자 한다.

예를 들어, 다음과 같이 10일 간의 온도가 주어졌을 때, 
모든 연속적인 이틀간의 온도의 합은 다음과 같다.

3   -2   -4   -9   0   3   7   13   8   -3 

  1   -6   -13  -9   3  10   20  21   5  


이때, 온도의 합이 가장 큰 값은 21이다.

매일 측정한 온도가 정수의 수열로 주어졌을 때, 
연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.

=============================================================================

▶ 입력설명
첫째 줄에는 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 순서대로 주어진다. 
첫 번째 정수 N은 온도를 측정한 전체 날짜의 수이다. 
N은 2 이상 100,000 이하이다. 

두 번째 정수 K는 합을 구하기 위한 연속적인 날짜의 수이다. 
K는 1과 N 사이의 정수이다. 

둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 
이 수들은 모두 -100 이상 100 이하이다.

▶ 출력설명
첫째 줄에는 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.

=============================================================================

▶ 입력예제
10 2
3 -2 -4 -9 0 3 7 13 8 -3

▶ 출력예제
21

*/

int main()
{
	// 최초의 풀이 (로직은 작동하지만 4번째 케이스부터 제한시간 초과)

	/*
	int n, k, count = 0, sum = 0, max = numeric_limits<int>::min();
	int heat[100000]{ 0 };

	cin >> n >> k;

	for (int i = 0; i < n; i++)
	{
		cin >> heat[i];
	}

	for (int i = 0; i <= n - k; i++)
	{
		sum += heat[i];

		count++;

		if (count >= k)
		{
			// 첫번째 인덱스부터 순차적으로 연속된 인덱스를 검사해야 하므로,
			// 검사 후 넘어간 인덱스에서 (검사 횟수 - 1)을 감소시켜 다음 차례 인덱스로 이동
			i -= (k - 1);
			count = 0;

			if (sum > max) max = sum;
			sum = 0;
		}
	}

	printf("%d\n", max);
	*/

	//============================================================================// 

	// 강의 풀이 1

	// 성능은 후지지만 작동하는 버전 (4번째 케이스부터 시간제한 초과)

	/*
	int n, k, sum = 0, max = numeric_limits<int>::min();

	cin >> n >> k;

	vector<int> heat(n);

	for (int i = 0; i < n; i++)
	{
		cin >> heat[i];
	}

	for (int i = 0; i <= n - k; i++)
	{
		sum = 0;

		for (int j = i; j < i + k; j++)
		{
			sum += heat[j];
		}

		if (sum > max) max = sum;
	}

	printf("%d\n", max);
	*/

	//============================================================================//

	// 강의 풀이 2

	/*
	int n, k, sum = 0, max = 0;

	cin >> n >> k;

	vector<int> heat(n);

	for (int i = 0; i < n; i++)
	{
		cin >> heat[i];
	}

	for (int i = 0; i < k; i++)
	{
		sum += heat[i];
	}

	max = sum;

	// 이미 첫 번째 최대값을 구해놓은 시점에서(검사 분기가 끝난 시점),
	// 다음 인덱스부터 값을 더하면서 이전 분기에서 가장 먼저 검사한 인덱스 값 차감

	for (int i = k; i < n; i++)
	{
		sum += (heat[i] - heat[i - k]);

		if (sum > max) max = sum;
	}

	printf("%d\n", max);
	*/

	//============================================================================//

	// 강의 풀이3 (약간의 최적화)

	int n, k, sum = 0, max = numeric_limits<int>::min();

	cin >> n >> k;

	vector<int> heat(n);

	for (int i = 0; i < n; i++)
	{
		cin >> heat[i];

		if (i < k) sum += heat[i];
	}

	max = sum;

	for (int i = k; i < n; i++)
	{
		sum += (heat[i] - heat[i - k]);

		if (sum > max) max = sum;
	}

	cout << max << endl;

	return 0;
}