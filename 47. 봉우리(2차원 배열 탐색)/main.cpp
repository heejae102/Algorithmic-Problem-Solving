#include<iostream>
using namespace std; 

// 1차 복습 풀이시간 : 17분 

/*

<47. 봉우리(2차원 배열 탐색)>

지도 정보가 N*N 격자판에 주어집니다. 
각 격자에는 그 지역의 높이가 쓰여있습니다. 
각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 
봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요.

격자의 가장자리는 0으로 초기화 되었다고 가정한다.
만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.

0  0  0  0  0  0  0
0 (5) 3 (7) 2 (3) 0
0  3 (7) 1 (6) 1  0
0 (7) 2  5  3 (4) 0
0  4  3 (6) 4  1  0
0 (8) 7  3 (5) 2  0
0  0  0  0  0  0  0

괄호로 친 부분이 봉우리 

=============================================================================

▶ 입력설명
첫 줄에 자연수 N이 주어진다. (1 <= N <= 50)
두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 
각 자연수는 100을 넘지 않는다.

▶ 출력설명
봉우리의 개수를 출력하세요.

=============================================================================

▶ 입력예제
5
5 3 7 2 3
3 7 1 6 1
7 2 5 3 4
4 3 6 4 1
8 7 3 5 2

▶ 출력예제
10

*/

int main()
{
	// 최초의 풀이 

	/*
	// 각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다.
	// 봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요.

	int n, count = 0;
	int arr[52][52] = { 0 };

	cin >> n; 

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			cin >> arr[i][j];
		}
	}

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			// && 연산으로 계산하려면 한번 검사할 때마다 
			// 모든 조건 분기를 검사해야 해서 느림. 

			// || 연산 시 조건이 안 맞으면 나머지 조건분기는 
			// 진행하지 않고 결과 값을 반환하므로 효율이 더 좋다. 

			if (arr[i - 1][j] >= arr[i][j] ||
				arr[i + 1][j] >= arr[i][j] ||
				arr[i][j - 1] >= arr[i][j] ||
				arr[i][j + 1] >= arr[i][j])
			{
				continue;;
			}

			count++;
		}
	}

	// 봉우리의 개수를 출력하세요.

	cout << count << endl; 
	*/

	//============================================================================//

	// 강의 풀이 (시간 복잡도가 후지고 가독성이 떨어진다는 생각을 지울 수 없다.)

	int n, flag, count = 0;
	int arr[52][52]{ 0 };
	int dx[4]{ -1,0,1,0 };
	int dy[4]{ 0,1,0,-1 };

	cin >> n;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			cin >> arr[i][j];
		}
	}

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			flag = 0;

			for (int k = 0; k < 4; k++)
			{
				if (arr[i][j] <= arr[i + dx[k]][j + dy[k]])
				{
					flag = 1;
					break;
				}
			}

			if (flag == 0)count++;
		}
	}

	cout << count << endl; 

	return 0;
}