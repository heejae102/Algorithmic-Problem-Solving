#include<stdio.h>
#include<iostream>
using namespace std; 

// 1차 복습 풀이시간 : 15분 (복습 필요 / 강의 풀이 응용 새로운 풀이법 추가)

/*

<30. 3의 개수는?(large : 제한시간 1초)>

자연수 N이 입력되면 1부터 N까지의 자연수를 종이에 적을 때
각 숫자 중 3의 개수가 몇 개 있는지 구하려고 합니다.

예를 들어 1부터 15까지는 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0,
1, 1, 1, 2, 1, 3, 1, 4, 1, 5으로 3의 개수는 2개입니다.

자연수 N이 입력되면 1부터 N까지 숫자를 적을 때,
3의 개수가 몇 개인지 구하여 출력하는 프로그램을 작성하세요.

=============================================================================

▶ 입력설명
첫 줄에 자연수의 개수 N(3 <= N <= 1,000,000,000)이 주어집니다.

▶ 출력설명
3의 개수를 출력하세요.

=============================================================================

▶ 입력예제
15

▶ 출력예제
2

*/

int main()
{
	// 최초의 풀이1 (60%, 케이스 4부터 시간제한 초과)

	/*
	int n, count = 0;

	cin >> n;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j *= 10)
		{
			if ((i / j) % 10 == 3) count++;
		}
	}

	cout << count << endl;
	*/

	//============================================================================//

	// 새로운 풀이 (강의 풀이 응용)

	// lDigit은 조건 확인에 사용되므로 반드시 초기화할 것.  

	int n, lDigit = 1, rDigit, curDigit, count = 0;

	cin >> n; 

	// 1234

	for (int i = 1; lDigit != 0; i *= 10)
	{
		lDigit = n / (i * 10);
		curDigit = (n / i) % 10;
		rDigit = n % i;

		if (curDigit > 3)
		{
			count += (lDigit + 1) * i;
		}
		else if (curDigit < 3)
		{
			count += lDigit * i;
		}
		else if (curDigit == 3)
		{
			count += (lDigit * i) + (rDigit + 1);
		}
	}

	cout << count << endl; 

	//============================================================================//

	// 강의 풀이 

	// 1의자리부터 돌아가면서 해당 수가 
	// 3과 같은가, 작은가, 큰가에 대한 분기를 나눠 개수 계산 

	/*
	int n, lt = 1, cur, rt, i = 1, count = 0;

	cin >> n; 
	
	// ex) 5367

	while (lt != 0)
	{
		lt = n / (i * 10);			// 536 
		cur = (n / i) % 10;			// 7
		rt = n % i;					// 0

		if (cur > 3)
		{
			count += (lt + 1) * i;			// 537 * 1 (0003 ~ 5363)
		}
		else if (cur < 3)
		{
			count += (lt * i);				// 536 * 1 (0003 ~ 5353)
		}
		else if (cur == 3)			
		{
			count += (lt * i) + (rt + 1);	// (536 * 1) + (0) (3이 존재하는 숫자까지 더하기) 
		}

		i *= 10;
	}

	cout << count << endl; 
	*/

	return 0;
}